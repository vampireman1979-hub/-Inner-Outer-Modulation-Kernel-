import numpy as np
from qiskit import QuantumCircuit

# ============================================================
# Angle model (shared)
# ============================================================

def _compute_angles(chi_value: float):
    decay = 20.0 * np.exp(-chi_value / 10_000.0)
    d = decay / 320.0
    theta = 2.0 * np.pi * d
    theta2 = theta / 2.0
    return theta, theta2


# ============================================================
# Base circuit + structural helpers (shared)
# ============================================================

def _new_base_circuit():
    qc = QuantumCircuit(5)
    q0, q1, q2, q3, q4 = 0, 1, 2, 3, 4
    return qc, q0, q1, q2, q3, q4


def _prepare_anchor_and_entangle_inner(qc, q2, q1, q3):
    qc.h(q2)
    qc.cx(q2, q1)
    qc.cx(q2, q3)


def _propagate_inner_to_outer(qc, q1, q3, q0, q4):
    qc.cx(q1, q0)
    qc.cx(q3, q4)


# ============================================================
# CLEAN INNER-LAYER MODULATION (formerly emoji-driven)
# ============================================================

def _inner_modulation(qc, q1, q3, theta):
    """
    Clean, explicit inner-layer modulation sequence.
    Replaces all symbolic/emoji triggers with deterministic operations.
    """

    # Heat pulse (was â™¨ï¸)
    qc.rz(theta * 0.1, q1)
    qc.rz(theta * 0.1, q3)

    # Awareness loop (was ðŸ‘ï¸â€ðŸ—¨ï¸)
    qc.h(q1); qc.h(q3)
    qc.cx(q1, q3); qc.cx(q3, q1)
    qc.h(q1); qc.h(q3)

    # Reinforced protection (was â¸)
    qc.rz(theta * 0.2, q1)
    qc.rz(-theta * 0.2, q3)
    qc.cx(q1, q3); qc.cx(q3, q1)

    # Intensity divergence (was â€¼ï¸)
    qc.ry(theta * 0.3, q1)
    qc.ry(-theta * 0.3, q3)

    # Path shaping (was ðŸ›¤ï¸)
    qc.rz(theta * 0.15, q1)
    qc.rz(theta * 0.15, q3)

    # Echo loop (was ðŸ”‚)
    qc.cx(q1, q3)
    qc.cx(q3, q1)


# ============================================================
# CLEAN OUTER-LAYER IMPRINT (formerly emoji-driven)
# ============================================================

def _outer_imprint(qc, q0, q4, theta2):
    """
    Clean, explicit outer-layer imprint sequence.
    Replaces symbolic/emoji triggers with deterministic operations.
    """

    # Closing RZ (was ðŸª¦)
    qc.rz(theta2 * 0.1, q0)
    qc.rz(theta2 * 0.1, q4)

    # Protective RX (was ðŸ›¡ï¸)
    qc.rx(theta2 * 0.15, q0)
    qc.rx(-theta2 * 0.15, q4)

    # Heart coherence (was ðŸ’“)
    qc.ry(theta2 * 0.2, q0)
    qc.ry(theta2 * 0.2, q4)

    # Closing RZ again (was second ðŸª¦)
    qc.rz(theta2 * 0.1, q0)
    qc.rz(theta2 * 0.1, q4)


# ============================================================
# CLEAN KERNEL (no symbols, no emojis)
# ============================================================

def kernel_clean_pattern(chi_value: float) -> QuantumCircuit:
    """
    Clean version of the emoji-driven kernel.
    All symbolic triggers removed.
    All operations explicit.
    """

    qc, q0, q1, q2, q3, q4 = _new_base_circuit()
    theta, theta2 = _compute_angles(chi_value)

    # Phase 0: anchor + entanglement
    _prepare_anchor_and_entangle_inner(qc, q2, q1, q3)

    # Phase 1: inner modulation
    _inner_modulation(qc, q1, q3, theta)

    # Phase 2: propagate to outer layer
    _propagate_inner_to_outer(qc, q1, q3, q0, q4)

    # Phase 3: outer imprint
    _outer_imprint(qc, q0, q4, theta2)

    qc.measure_all()
    return qc
